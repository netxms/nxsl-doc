[.nxsl-class]
[[class-node]]
=== Node

Represents NetXMS node object. Extends <<class-datacollectiontarget>>.

==== Instance attributes

include::_shared/netobj-attrs.adoc[]

include::_shared/datacollectiontarget-attrs.adoc[]

[.attr-list]
--
[[node-agentCertificateMappingData]]
agentCertificateMappingData => String::
Agent certificate mapping data (set in object properties).

[[node-agentCertificateMappingMethod]]
agentCertificateMappingMethod => String::
Agent certificate mapping method (set in object properties).

[[node-agentCertificateSubject]]
agentCertificateSubject => String::
Subject of certificate issued for agent tunnel on this node.

[[node-agentId]]
agentId => String::
NetXMS agent unique ID (`string` representation of GUID). Will return all zeroes GUID if agent is not detected on node or does not have unique ID.

[[node-agentProxy]]
agentProxy => <<class-node>>::
Object that is set as agent proxy in object properties or NULL.

[[node-agentVersion]]
agentVersion => String::
NetXMS agent version as `string`.

[[node-bootTime]]
bootTime => Integer64::
UNIX time (number of seconds since epoch) of the moment when node was started or `0` if unknown.

[[node-bridgeBaseAddress]]
bridgeBaseAddress => String::
Base address of the switch formatted as 12 character `string` without separators. Value is only valid for bridges and switches. Special value `000000000000` indicates that address is unknown.

[[class-node-capabilities,Node::capabilities]]
capabilities => Integer::
Detected node capabilities ("Have Agent", "Support SNMP", etc.) Bitwise AND of <<node-capabilities>> constants.

[[node-cipDeviceType]]
cipDeviceType => Integer::
EtherNet/IP device type

[[node-cipDeviceTypeAsText]]
cipDeviceTypeAsText => String::
EtherNet/IP device type as text

[[node-cipExtendedStatus]]
cipExtendedStatus => Integer::
EtherNet/IP device extended status

[[node-cipExtendedStatusAsText]]
cipExtendedStatusAsText => String::
EtherNet/IP device extended status as text

[[node-cipState]]
cipState => Integer::
EtherNet/IP device state

[[node-cipStateAsText]]
cipStateAsText => String::
EtherNet/IP device state as text

[[node-cipStatus]]
cipStatus => Integer::
EtherNet/IP device status

[[node-cipStatusAsText]]
cipStatusAsText => String::
EtherNet/IP device status as text

[[node-cipVendorCode]]
cipVendorCode => Integer::
EtherNet/IP vendor code in numeric form.

[[node-cluster]]
cluster => <<class-cluster>>::
Cluster this node is in.

[[node-components]]
components => <<class-component>>::
Entity MIB components of class <<class-component>>.

[[node-dependentNodes]]
dependentNodes => Array::
Will return array with <<class-nodedependency>> class objects. This array contains all objects that have current node as a proxy or data collection sources.

[[node-downSince]]
downSince => Integer64::
UNIX timestamp when node went down.

[[node-driver]]
driver => String::
Named of selected device-specific SNMP driver.

[[node-expectedCapabilities]]
expectedCapabilities => Integer::
Expected capabilities mask for the node. Bitwise AND of <<node-capabilities>> constants.

[[node-effectiveAgentProxy]]
effectiveAgentProxy => <<class-node>>::
Object that is effective agent proxy or NULL.

[[node-effectiveIcmpProxy]]
effectiveIcmpProxy => <<class-node>>::
Object that is effective ICMP proxy or NULL.

[[node-effectiveSnmpProxy]]
effectiveSnmpProxy => <<class-node>>::
Object that is effective SNMP proxy or NULL.

[[node-flagsAttr]]
flags => Integer::
Bit mask of <<node-flags>>.

[[node-hardwareComponents]]
hardwareComponents => Array::
Returns an array of available hardware of class <<class-hardwarecomponent>>.

[[node-hardwareId]]
hardwareId => String::
Nodes' unique hardware id

[[node-hasAgentIfXCounters]]
hasAgentIfXCounters => Boolean::
`TRUE` if agent supports 64-bit interface counters.

[[node-hasEntityMIB]]
hasEntityMIB => Boolean::
`TRUE` if supports ENTITY-MIB.

[[node-hasServiceManager]]
hasServiceManager => Boolean::
`TRUE` if node has service manager accessible via NetXMS agent.

[[node-hasIfXTable]]
hasIfXTable => Boolean::
`TRUE` if supports ifXTable via SNMP (64-bit counters for interface statistics).

[[node-hasUserAgent]]
hasUserAgent => Boolean::
`TRUE` if has user agent

[[node-hasVLANs]]
hasVLANs => Boolean::
`TRUE` if VLAN information available.

[[node-hasWinPDH]]
hasWinPDH => Boolean::
`TRUE` if node supports Windows PDH parameters.

[[node-hypervisorInfo]]
hypervisorInfo => String::
Additional information about hypervisor for this node.

[[node-hypervisorType]]
hypervisorType => String::
Hypervisor type as `string` (usually hypervisor vendor or product name, like VMWare or XEN).

[[node-icmpAverageRTT]]
icmpAverageRTT => Integer::
ICMP average response time for primary address. Will return null if no information.

[[node-icmpLastRTT]]
icmpLastRTT => Integer::
ICMP last response time for primary address. Will return null if no information.

[[node-icmpMaxRTT]]
icmpMaxRTT => Integer::
ICMP maximal response time for primary address. Will return null if no information.

[[node-icmpMinRTT]]
icmpMinRTT => Integer::
ICMP minimal response time for primary address. Will return null if no information.

[[node-icmpPacketLoss]]
icmpPacketLoss => Integer::
ICMP packet loss for primary address. Will return null if no information.

[[node-icmpProxy]]
icmpProxy => <<class-node>>::
Object that is set as ICMP proxy in object properties or NULL.

[[node-interfaces]]
interfaces => Array::
Array with <<class-interface>> objects, that are under this node. First object placed at index 0.

[[node-is802_1x]]
is802_1x => Boolean::
`TRUE` if node supports 802.1x. Equivalent of `isPAE`.

[[node-isAgent]]
isAgent => Boolean::
`TRUE` if NetXMS agent detected on node

[[node-isBridge]]
isBridge => Boolean::
`TRUE` if node is a bridge

[[node-isCDP]]
isCDP => Boolean::
`TRUE` if node supports CDP (Cisco Discovery Protocol)

[[node-isDecommissioned]]
isDecommissioned => Boolean::
`TRUE` if node is decommissioned.

[[node-isEtherNetIP]]
isEtherNetIP => Boolean::
`TRUE` if node supports EtherNet/IP (Industrial Protocol)

[[node-isExternalGateway]]
isExternalGateway => Boolean::
`TRUE` if node is an external gateway (remotely managed node). Alias: `isRemotelyManaged`.

[[node-isInMaintenanceMode]]
isInMaintenanceMode => Boolean::
`TRUE` if node is in maintenance mode

[[node-isLLDP]]
isLLDP => Boolean::
`TRUE` if node supports LLDP (Link Layer Discovery Protocol)

[[node-isLocalManagement]]
isLocalManagement => Boolean::
`TRUE` if node is a local management server (NetXMS server)

[[node-isLocalMgmt]]
isLocalMgmt => Boolean::
`TRUE` if node is a local management server (NetXMS server)

[[node-isModbusTCP]]
isModbusTCP => Boolean::
`TRUE` if node supports Modbus TCP

[[node-isNativeAgent]]
isNativeAgent => Boolean::
`TRUE` if node is a native agent.

[[node-isNDP]]
isNDP => Boolean::
`TRUE` if node supports OSPF/NDP. Equivalent of `isOSPF`.

[[node-isOSPF]]
isOSPF => Boolean::
`TRUE` if node supports OSPF/NDP. Equivalent of `isNDP`.

[[node-isPAE]]
isPAE => Boolean::
`TRUE` if node supports 802.1x. Equivalent of `is802_1x`.

[[node-isPrinter]]
isPrinter => Boolean::
`TRUE` if node is a printer

[[node-isProfiNet]]
isProfiNet => Boolean::
`TRUE` if node supports PROFINET (Process Field Network)

[[node-isRouter]]
isRouter => Boolean::
`TRUE` if node is a router (has IP forwarding enabled)

[[node-isSMCLP]]
isSMCLP => Boolean::
`TRUE` if node supports SMCLP (Server Management Command Line Protocol)

[[node-isSNMP]]
isSNMP => Boolean::
`TRUE` if SNMP agent detected on node

[[node-isSONMP]]
isSONMP => Boolean::
`TRUE` if node supports SONMP/NDP (Synoptics/Nortel Discovery Protocol)

[[node-isSSH]]
isSSH => Boolean::
`TRUE` if SSH is connection available

[[node-isSSHCommandChannelAvailable]]
isSSHCommandChannelAvailable => Boolean::
`TRUE` if SSH command channel can be established to this node.

[[node-isSSHInteractiveChannelAvailable]]
isSSHInteractiveChannelAvailable => Boolean::
`TRUE` if SSH interactive (shell) channel can be established to this node.

[[node-isSTP]]
isSTP => Boolean::
`TRUE` if node supports STP (Spanning Tree Protocol)

[[node-isVirtual]]
isVirtual => Boolean::
`TRUE` if node is virtual

[[node-isVRRP]]
isVRRP => Boolean::
`TURE` if VRRP supported.

[[node-isWirelessAP]]
isWirelessAP => Boolean::
`TURE` if node is wireless access point

[[node-isWirelessController]]
isWirelessController => Boolean::
`TURE` if node is wireless controller

[[node-lastAgentCommTime]]
lastAgentCommTime => Integer::
Unix timestamp of last time when communication with agent was

[[node-modbusProxy]]
modbusProxy => <<class-node>>::
MODBUS proxy object

[[node-modbusProxyId]]
modbusProxyId => Integer::
MODBUS proxy object id

[[node-modbusTCPPort]]
modbusTCPPort => Integer::
MODBUS TCP port

[[node-modbusUnitId]]
modbusUnitId => Integer::
MODBUS unit id

[[node-networkPathCheckResult]]
networkPathCheckResult => <<class-networkpathcheckresult>>::
Node network path

[[node-nodeSubType]]
nodeSubType => String::
Node sub type

[[class-node-types,Node::types]]
nodeType => Integer::
Node type <<node-types>>

[[node-ospfAreas]]
ospfAreas => <<class-ospfarea>>::
Returns <<class-ospfarea>> class object

[[node-ospfNeighbors]]
ospfNeighbors => Array::
Array with <<class-ospfarea>> class objects

[[node-ospfRouterId]]
ospfRouterId => String::
OSPF router ID

[[node-physicalContainer]]
physicalContainer => Object::
Physical container object: Rack <<class-netobj>> or Chassis <<class-chassis>>

[[node-physicalContainerId]]
physicalContainerId => Integer::
Physical container object id (Rack or Chassis)

[[node-platformName]]
platformName => String::
Platform name reported by NetXMS agent

[[node-pollCountForStatusChange]]
pollCountForStatusChange => Integer::
Number of polls required before registering a status change.

[[node-primaryHostName]]
primaryHostName => String::
Primary host name

[[node-productCode]]
productCode => String::
Hardware system property - product code

[[node-productName]]
productName => String::
Hardware system property - product name

[[node-productVersion]]
productVersion => String::
Hardware system property - product version

[[node-rack]]
rack => <<class-netobj>>::
Will return Rack object as <<class-netobj>> if node is added in rack

[[node-rackHeight]]
rackHeight => Integer::
Object height in rack

[[node-rackId]]
rackId => Integer::
Will return Rack id if node is added in rack

[[node-rackPosition]]
rackPosition => Integer::
Object position in rack

[[node-runtimeFlags]]
runtimeFlags => Integer::
Bit mask of <<node-runtime-flags>>, `uint32`.

[[node-serialNumber]]
serialNumber => String::
Serial number from hardware system property

[[node-snmpOID]]
snmpOID => String::
SNMP object identifier (result of `1.3.6.1.2.1.1.2.0` request)

[[node-snmpProxy]]
snmpProxy => <<class-node>>::
Object that is set as SNMP proxy in object properties or NULL.

[[node-snmpProxyId]]
snmpProxyId => Integer::
SNMP proxy object id.

[[node-snmpSysContact]]
snmpSysContact => String::
SNMP system contact (result of `1.3.6.1.2.1.1.4.0` request)

[[node-snmpSysLocation]]
snmpSysLocation => String::
SNMP system location (result of `1.3.6.1.2.1.1.6.0` request)

[[node-snmpSysName]]
snmpSysName => String::
SNMP system name (result of `1.3.6.1.2.1.1.5.0` request)

[[node-snmpVersion]]
snmpVersion => Integer::
Configured SNMP version:
+
* 0: SNMP version 1
* 1: SNMP version 2c
* 2: SNMP version 3

[[node-softwarePackages]]
softwarePackages => Array::
Returns array of <<class-softwarepackage>> class objects

[[node-sysDescription]]
sysDescription => String::
System description (value of `System.Uname` for nodes with agents or `1.3.6.1.2.1.1.1.0` for SNMP nodes)

[[node-tunnel]]
tunnel => <<class-tunnel>>::
Tunnel object f this node or NULL if there is no tunnel active and bound to this node.

[[node-vendor]]
vendor => String::
Hardware vendor information

[[node-vlans]]
vlans => Array::
Array with object <<class-vlan>> objects (`null` if there are no VLANs)

[[node-wirelessDomain]]
wirelessDomain => <<class-wirelessdomain>>::
Wireless domain of this node

[[node-wirelessDomainId]]
wirelessDomainId => Integer::
Wireless domain id of this node

[[node-wirelessStations]]
wirelessStations => Array::
Array with object <<class-wirelessstation>> objects (`null` if there are no Wireless Stations)

[[node-zone]]
zone => <<class-zone>>::
<<class-zone>> object (`null` if zoning is disabled)

[[node-zoneProxyAssignments]]
zoneProxyAssignments => Integer::
Number of objects where this node is selected as either primary or backup zone proxy (`0` if zoning is disabled or this node is not a zone proxy).

[[node-zoneProxyStatus]]
zoneProxyStatus => Boolean::
Status of this node as zone proxy (`true` if active).

[[node-zoneUIN]]
zoneUIN => Integer::
This node zone UIN
--

==== Instance methods

include::_shared/netobj-methods.adoc[]

include::_shared/datacollectiontarget-methods.adoc[]

[.method-list]
--
[[node-callWebService]]
callWebService(webSvcName, requestType, ...) => <<class-webserviceresponse>>::
Finds web service by name, makes request and returns the <<class-webserviceresponse>> object.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|webSvcName|String|Web service name.
|requestType|String|Request type. One of: GET, DELETE, PATCH, POST, PUT
|data|String or <<class-jsonobject>> |Depending on request type data might be required and provided as a string or JSON object. GET and DELETE requests do not allow data, PATCH, POST, PUT require data.
|contentType|String|Optional parameter, for PATCH, POST and PUT requests only. Type of provided data that will be set to "Content-Type" header of request. Default type is "application/json".
|acceptCached|Boolean|Optional named parameter. If True, response stored in agent's cache will be used. Default: false.
|...|Strings|Optional additional parameter(s) that will be used in web service definition to expand %1, %2... macro.
|===
+
.Return
Instance of <<class-webserviceresponse>> with request result.
+
[.source]
....
// Valid example when request fails because there is no connection to agent
result = $node.callWebService("Web service name", "GET", "additional/ult/path");
println(result.success); // "false"
println(result.errorMessage); // "No connection with agent"
println(result.agentErrorCode); // "0"
println(result.httpResponseCode); // "0"
println(result.document); // ""

// Successful post request
result = $node.callWebService("Web service name", "POST", "{ \"id\":10 }", "application/json", "additional/ult/path");
println(result.success); // "true"
println(result.errorMessage); // ""
println(result.agentErrorCode); // "0"
println(result.httpResponseCode); // "200"
println(result.document); // ""

// Get requests
result = $node.callWebService("Web service name", "GET", "additional", "parameters");
result = $node.callWebService("Web service name", "GET", acceptCached: true, "additional", "parameters);
....

[[node-createSNMPTransport]]
createSNMPTransport(port, community, context, failIfUnreachable) => <<class-snmptransport>>::
Create SNMP transport object of class <<class-snmptransport>> with communication settings defined on the node. It is possible to specify a community string but only community strings listed in Network Credentials will be accepted.
Creation of SNMP transport is a preparatory operation enabling subsequent sending of SNMP requests to node.
However, creation of SNMP transport does not guarantee that the node is accessible.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|port|Integer|Optional parameter with port.
|community|String|Optional parameter with community string.
|context|String|Optional parameter with context.
|failIfUnreachable|String|Optional parameter, is provided and is true, check that SNMP is reachable on the node before creating SNMP transport.
|===
+
[.version-added]
Added in version 4.4.1: `failIfUnreachable` parameter
+
.Return
Instance of <<class-snmptransport>> or `null` if failed or node was not reacheable when failIfUnreachable was set to true.

[[node-enable8021xStatusPolling]]
enable8021xStatusPolling(flag) => void::
Enable or disable 802.1x port state checking during status polls.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|flag|Boolean|If 802.1x port state checking should be enabled.
|===

[[node-enableAgent]]
enableAgent(flag) => void::
Enable or disable usage of NetXMS agent for all polls.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|flag|Boolean|If agent usage should be enabled.
|===

[[node-enableDiscoveryPolling]]
enableDiscoveryPolling(flag) => void::
Enable or disable discovery polling.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|flag|Boolean|If discovery polling should be enabled.
|===

[[node-enableEtherNetIP]]
enableEtherNetIP(flag) => void::
Enable or disable usage of EtherNet/IP for polls.
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|flag|Boolean|If EtherNet/IP should be enabled.
|===

[[node-enableIcmp]]
enableIcmp(flag) => void::
Enable or disable usage of ICMP pings for status polls.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|flag|Boolean|If ICMP pings should be enabled.
|===

[[node-enableModbusTcp]]
enableModbusTcp(flag) => void::
Enable or disable usage of Modbus TCP for polls.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|flag|Boolean|If Modbus TCP should be enabled.
|===

[[node-enablePrimaryIPPing]]
enablePrimaryIPPing(flag) => void::
Enable or disable usage of ICMP ping for primary IP.
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|flag|Boolean|If primary IP ping should be enabled.
|===

[[node-enableRoutingTablePolling]]
enableRoutingTablePolling(flag) => void::
Enable or disable routing table polling.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|flag|Boolean|If routing table polls should be enabled.
|===

[[node-enableSnmp]]
enableSnmp(flag) => void::
Enable or disable usage of SNMP for all polls.
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|flag|Boolean|If SNMP communication should be enabled.
|===

[[node-enableSmclpPropertyPolling]]
enableSmclpPropertyPolling(flag) => void::
Enable or disable reading of SM-CLP available properties metadata during
configuration poll.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|flag|Boolean|If 802.1x port state checking should be enabled.
|===

[[node-enableSsh]]
enableSsh(flag) => void::
Enable or disable usage of SSH
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|flag|Boolean|If SSH communication should be enabled.
|===

[[node-enableTopologyPolling]]
enableTopologyPolling(flag) => void::
Enable or disable topology polling.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|flag|Boolean|If topology polls should be enabled.
|===

[[node-enableVnc]]
enableVnc(flag) => void::
Enable or disable VNC detection on the node during configuration poll.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|flag|Boolean|If VNC detection should be enabled.
|===

[[node-enableWinPerfCountersCache]]
enableWinPerfCountersCache(flag) => void::
Enable or disable reading of Windows performance counters metadata during
configuration poll.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|flag|Boolean|If reading of Windows performance counters metadata should be enabled.
|===

[[node-executeAgentCommand]]
executeAgentCommand(command, ...) => Boolean::
Execute agent command (action) on node.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|command|String|Command to be executed.
|...|String|Optional arguments for command
|===
+
.Return
True if command execution is successful or false otherwise.

[[node-executeAgentCommandWithOutput]]
executeAgentCommandWithOutput(command, ...) => String::
Execute agent command (action) on node and return it's output.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|command|String|Command to be executed.
|...|String|Optional arguments for command
|===
+
.Return
String with output of the command or null on failure.

[[node-executeSSHCommand]]
executeSSHCommand(command) => array::
Execute SSH command on node.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|command|String|Command to be executed.
|===
+
.Return
Array of strings with output of the command or null on failure.

[[class-node-getblockedports,Node::getBlockedPorts()]]
getBlockedPorts(protocol) => Array::
Get array of blocked ports for the specified protocol.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|protocol|String|Protocol type - "tcp" or "udp"
|===
+
.Return
Array of integers representing blocked port numbers.
+
[.source]
....
blockedTcpPorts = $node->getBlockedPorts("tcp");
foreach (port : blockedTcpPorts) {
    println("Blocked TCP port: " .. port);
}
....

[[class-node-getinstalledpackages,Node::getInstalledPackages()]]
getInstalledPackages(filter, useRegex) => Array::
Get array of installed packages on the node.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|filter|String|Optional package name filter
|useRegex|Boolean|Optional. If TRUE, use regex matching for filter. Default is FALSE
|===
+
.Return
Array of installed packages on the node.
+
[.source]
....
// Get all packages
packages = $node->getInstalledPackages();

// Get packages matching filter
packages = $node->getInstalledPackages("netxms", false);
....

[[class-node-getinterface,Node::getInterface()]]
getInterface(ifIdentifier) => <<class-interface>>::
Get interface object by index, MAC address or name. If
name is number method will assume that it is index.
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|ifIdentifier|Integer or String|Index, MAC address or name of interface.
|===
+
.Return
<<class-interface>> object.
+
[.source]
....
println($node.getInterface("00:14:22:04:25:37").name); // Will print "wlp4s0"
println($node.getInterface(3).name); // Will print "wlp4s0"
println($node.getInterface("wlp4s0").name); // Will print "wlp4s0"
....

[[class-node-getinterfacebyindex,Node::getInterfaceByIndex()]]
getInterfaceByIndex(ifIndex) => <<class-interface>>::
Get interface object by index.
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|ifIndex|Integer|Index of interface.
|===
+
.Return
<<class-interface>> object.
+
[.source]
....
println($node.getInterfaceByIndex(3).name); // Will print "wlp4s0"
....

[[class-node-getinterfacebymacaddress,Node::getInterfaceByMACAddress()]]
getInterfaceByMACAddress(ifMACAddr) => <<class-interface>>::
Get interface object by MAC address.
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|ifMACAddr|String|MAC address of interface.
|===
+
.Return
<<class-interface>> object.
+
[.source]
....
println($node.getInterfaceByMACAddress("00:14:22:04:25:37").name); // Will print "wlp4s0"
....

[[class-node-getinterfacebyname,Node::getInterfaceByName()]]
getInterfaceByName(IfName) => <<class-interface>>::
Get interface object by name.
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|IfName|String|Name of interface.
|===
+
.Return
<<class-interface>> object.
+
[.source]
....
println($node.getInterfaceByName("wlp4s0").name); // Will print "wlp4s0"
....

[[node-getInterfaceName]]
getInterfaceName(ifIndex) => String::
Get interface name by index.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|ifIndex|Integer|Index of interface.
|===

[[class-node-isportblocked,Node::isPortBlocked()]]
isPortBlocked(port, protocol) => Boolean::
Check if a specific port is blocked for the given protocol.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|port|Integer|Port number (1-65535)
|protocol|String|Protocol - "tcp" or "udp"
|===
+
.Return
TRUE if the port is blocked, FALSE otherwise.
+
[.source]
....
if ($node->isPortBlocked(22, "tcp")) {
    println("SSH port is blocked");
}
....

[[node-getWebService]]
getWebService(webSvcName) => <<class-webservice>>::
Get web service object by name.
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|webSvcName|String|Name of interface.
|===
+
.Return
<<class-webservice>> object.
+
[.source]
....
webSvc = $node.getWebService("webSvcName");
....

[[class-node-opensshsession,Node::openSSHSession()]]
openSSHSession(user, password, keyId) => <<class-sshsession>>::
Open an interactive SSH session to this node.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|user|String|Optional SSH login username
|password|String|Optional SSH password
|keyId|Integer|Optional SSH key identifier
|===
+
.Return
<<class-sshsession>> object on success, or NULL on failure.
+
[.source]
....
session = $node->openSSHSession();
if (session != null && session->connected) {
    output = session->execute("ls -la");
    foreach (line : output) {
        println(line);
    }
    session->close();
}
....

[[class-node-readagentlist,Node::readAgentList()]]
readAgentList(name) => Array::
Request agent list directly from agent on given node. Returns array of strings or `NULL` if failed.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|name|String|List name.
|===

[[class-node-readagentparameter,Node::readAgentParameter()]]
readAgentParameter(name) => String::
Request metric directly from agent on given node. Returns `NULL` if failed.
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|name|String|Metric name.
|===

[[class-node-readagenttable,Node::readAgentTable()]]
readAgentTable(name) => <<class-table>>::
Requests agent table directly from agent on given node. Returns <<class-table>> or `NULL` if failed.
+
.Parameters
[cols="1,1a,3a" grid="none", frame="none"]
|===
|name|String|Table name.
|===

[[class-node-readdriverparameter,Node::readDriverParameter()]]
readDriverParameter(name) => String::
Request driver-specific metric from network device driver (e.g. Rital).
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|name|String|List name.
|===

[[node-readInternalParameter]]
readInternalParameter(name) => String::
Read internal parameter
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|name|String|Parameter name
|===
+
.Return
Value of requested internal parameter

[[node-readInternalTable]]
readInternalTable(name) => <<class-table>>::
Read internal table
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|name|String|Table name
|===
+
.Return
Value of requested internal table of class <<class-table>>

[[class-node-readWebServiceList,Node::readWebServiceList()]]
readWebServiceList(name) => Array::
Read list from node using web service
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|name|String|Name is expected in form service:path or service(arguments):path
|===
+
.Return
Array with string with web service instances

[[class-node-readWebServiceParameter,Node::readWebServiceParameter()]]
readWebServiceParameter(name) => String::
Read from node web service parameter
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|name|String|Name is expected in form service:path or service(arguments):path
|===
+
.Return
String with result read from web service

[[node-setExpectedCapabilities]]
setExpectedCapabilities(capabilities) => void::
Set the expected capabilities for this node.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|capabilities|Integer|Capability flags bitmask. Only allows capability bits for: native agent, SNMP, EtherNet/IP, Modbus TCP, and SSH.
|===

[[node-setIfXTableUsageMode]]
setIfXTableUsageMode(mode) => void::
Set ifXTable usage mode 0 - use default, 1 - enable, 2 - disable
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|mode|Integer|usage mode
|===

[[node-setPollCountForStatusChange]]
setPollCountForStatusChange(count) => void::
Set the required number of polls before registering a status change.
+
.Parameters
[cols="1,1,3a" grid="none", frame="none"]
|===
|count|Integer|Number of polls (must be >= 0)
|===
--

==== Constants

[[node-flags]]
[cols="1,4a"]
.Node flags
|===
| Description | Value

|DCF_DISABLE_STATUS_POLL
|0x00000001

|DCF_DISABLE_CONF_POLL
|0x00000002

|DCF_DISABLE_DATA_COLLECT
|0x00000004

|DCF_LOCATION_CHANGE_EVENT
|0x00000008

|NF_EXTERNAL_GATEWAY
|0x00010000

|NF_DISABLE_DISCOVERY_POLL
|0x00020000

|NF_DISABLE_TOPOLOGY_POLL
|0x00040000

|NF_DISABLE_SNMP
|0x00080000

|NF_DISABLE_NXCP
|0x00100000

|NF_DISABLE_ICMP
|0x00200000

|NF_FORCE_ENCRYPTION
|0x00400000

|NF_DISABLE_ROUTE_POLL
|0x00800000

|NF_AGENT_OVER_TUNNEL_ONLY
|0x01000000

|NF_SNMP_SETTINGS_LOCKED
|0x02000000

|NF_PING_PRIMARY_IP
|0x04000000

|NF_DISABLE_ETHERNET_IP
|0x08000000

|NF_DISABLE_PERF_COUNT
|0x10000000

|===

[[node-runtime-flags]]
[cols="1,4a"]
.Node runtime flags
|===
| Description | Value

|DCDF_QUEUED_FOR_STATUS_POLL
|0x00000001

|DCDF_QUEUED_FOR_CONFIGURATION_POLL
|0x00000002

|DCDF_QUEUED_FOR_INSTANCE_POLL
|0x00000004

|DCDF_DELETE_IN_PROGRESS
|0x00000008

|DCDF_FORCE_STATUS_POLL
|0x00000010

|DCDF_FORCE_CONFIGURATION_POLL
|0x00000020

|DCDF_CONFIGURATION_POLL_PASSED
|0x00000040

|DCDF_CONFIGURATION_POLL_PENDING
|0x00000080

|NDF_QUEUED_FOR_TOPOLOGY_POLL
|0x00010000

|NDF_QUEUED_FOR_DISCOVERY_POLL
|0x00020000

|NDF_QUEUED_FOR_ROUTE_POLL
|0x00040000

|NDF_RECHECK_CAPABILITIES
|0x00080000

|NDF_NEW_TUNNEL_BIND
|0x00100000

|===

[[node-capabilities]]
[cols="1,5a"]
.Node capability flags
|===
| Value | Description

|0x00000001
|Node supports SNMP

|0x00000002
|NetXMS agent detected on the node

|0x00000004
|Node is network bridge

|0x00000008
|Node is IP router

|0x00000010
|Node is management server (NetXMS server itself)

|0x00000020
|Node is printer

|0x00000040
|Node supports OSPF

|0x00000080
|CheckPoint SNMP agent detected on port 260

|0x00000100
|CDP supported

|0x00000200
|NDP(SONMP) support detected on the node (Nortel/Synoptics/Bay Networks) topology discovery)

|0x00000400
|Node supports LLDP

|0x00000800
|Node supportes VRRP

|0x00001000
|VLAN information available on the node

|0x00002000
|802.1x support detected

|0x00004000
|Spanning Tree (IEEE 802.1d) enabled on node

|0x00008000
|Node supports ENTITY-MIB

|0x00010000
|Node supports ifXTable via SNMP (64-bit counters for interface statistics)

|0x00020000
|Agent supports 64-bit interface counters

|0x00040000
|Node supports Windows PDH parameters

|0x00080000
|Node is wireless network controller

|0x00100000
|Node supports SMCLP protocol

|0x00200000
|Running agent is upgraded to new policy type

|0x00400000
|User (support) agent is installed

|===


[[node-types]]
[cols="1,5a"]
.Node types
|===
| Value | Description

|0
|Unknown

|1
|Physical

|2
|Virtual

|3
|Controller

|4
|Container

|===

.See also
<<func-findnodeobject>>, <<func-findnodebyipaddress>>, <<func-findnodebysysname>>, <<func-findnodebymacaddress>>, <<func-getallnodes>>, <<class-interface>>, <<class-datacollectiontarget>>
